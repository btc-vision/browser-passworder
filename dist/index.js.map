{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as utils from '@metamask/utils';\r\n\r\nexport type DetailedEncryptionResult = {\r\n  vault: string;\r\n  exportedKeyString: string;\r\n};\r\n\r\nexport type PBKDF2Params = {\r\n  iterations: number;\r\n};\r\n\r\nexport type KeyDerivationOptions = {\r\n  algorithm: 'PBKDF2';\r\n  params: PBKDF2Params;\r\n};\r\n\r\nexport type EncryptionKey = {\r\n  key: CryptoKey;\r\n  derivationOptions: KeyDerivationOptions;\r\n};\r\n\r\nexport type ExportedEncryptionKey = {\r\n  key: JsonWebKey;\r\n  derivationOptions: KeyDerivationOptions;\r\n};\r\n\r\nexport type EncryptionResult = {\r\n  data: string;\r\n  iv: string;\r\n  salt?: string;\r\n  // old encryption results will not have this\r\n  keyMetadata?: KeyDerivationOptions;\r\n};\r\n\r\nexport type DetailedDecryptResult = {\r\n  exportedKeyString: string;\r\n  vault: unknown;\r\n  salt: string;\r\n};\r\n\r\nconst EXPORT_FORMAT = 'jwk';\r\nconst DERIVED_KEY_FORMAT = 'AES-GCM';\r\nconst STRING_ENCODING = 'utf-8';\r\nconst OLD_DERIVATION_PARAMS: KeyDerivationOptions = {\r\n  algorithm: 'PBKDF2',\r\n  params: {\r\n    iterations: 10_000,\r\n  },\r\n};\r\nconst DEFAULT_DERIVATION_PARAMS: KeyDerivationOptions = {\r\n  algorithm: 'PBKDF2',\r\n  params: {\r\n    iterations: 900_000,\r\n  },\r\n};\r\n\r\n/**\r\n * Encrypts a data object that can be any serializable value using\r\n * a provided password.\r\n *\r\n * @param password - The password to use for encryption.\r\n * @param dataObj - The data to encrypt.\r\n * @param key - The CryptoKey to encrypt with.\r\n * @param salt - The salt to use to encrypt.\r\n * @param keyDerivationOptions - The options to use for key derivation.\r\n * @returns The encrypted vault.\r\n */\r\nexport async function encrypt<R>(\r\n  password: string,\r\n  dataObj: R,\r\n  key?: EncryptionKey | CryptoKey,\r\n  salt: string = generateSalt(),\r\n  keyDerivationOptions = DEFAULT_DERIVATION_PARAMS,\r\n): Promise<string> {\r\n  const cryptoKey =\r\n    key || (await keyFromPassword(password, salt, false, keyDerivationOptions));\r\n  const payload = await encryptWithKey(cryptoKey, dataObj);\r\n  payload.salt = salt;\r\n  return JSON.stringify(payload);\r\n}\r\n\r\n/**\r\n * Encrypts a data object that can be any serializable value using\r\n * a provided password.\r\n *\r\n * @param password - A password to use for encryption.\r\n * @param dataObj - The data to encrypt.\r\n * @param salt - The salt used to encrypt.\r\n * @param keyDerivationOptions - The options to use for key derivation.\r\n * @returns The vault and exported key string.\r\n */\r\nexport async function encryptWithDetail<R>(\r\n  password: string,\r\n  dataObj: R,\r\n  salt = generateSalt(),\r\n  keyDerivationOptions = DEFAULT_DERIVATION_PARAMS,\r\n): Promise<DetailedEncryptionResult> {\r\n  const key = await keyFromPassword(password, salt, true, keyDerivationOptions);\r\n  const exportedKeyString = await exportKey(key);\r\n  const vault = await encrypt(password, dataObj, key, salt);\r\n\r\n  return {\r\n    vault,\r\n    exportedKeyString,\r\n  };\r\n}\r\n\r\n/**\r\n * Encrypts the provided serializable javascript object using the\r\n * provided CryptoKey and returns an object containing the cypher text and\r\n * the initialization vector used.\r\n *\r\n * @param encryptionKey - The CryptoKey to encrypt with.\r\n * @param dataObj - A serializable JavaScript object to encrypt.\r\n * @returns The encrypted data.\r\n */\r\nexport async function encryptWithKey<R>(\r\n  encryptionKey: EncryptionKey | CryptoKey,\r\n  dataObj: R,\r\n): Promise<EncryptionResult> {\r\n  const data = JSON.stringify(dataObj);\r\n  const dataBuffer = Buffer.from(data, STRING_ENCODING);\r\n  const vector = globalThis.crypto.getRandomValues(new Uint8Array(16));\r\n  const key = unwrapKey(encryptionKey);\r\n\r\n  const buf = await globalThis.crypto.subtle.encrypt(\r\n    {\r\n      name: DERIVED_KEY_FORMAT,\r\n      iv: vector,\r\n    },\r\n    key,\r\n    dataBuffer,\r\n  );\r\n\r\n  const buffer = new Uint8Array(buf);\r\n  const vectorStr = Buffer.from(vector).toString('base64');\r\n  const vaultStr = Buffer.from(buffer).toString('base64');\r\n  const encryptionResult: EncryptionResult = {\r\n    data: vaultStr,\r\n    iv: vectorStr,\r\n  };\r\n\r\n  if (isEncryptionKey(encryptionKey)) {\r\n    encryptionResult.keyMetadata = encryptionKey.derivationOptions;\r\n  }\r\n\r\n  return encryptionResult;\r\n}\r\n\r\n/**\r\n * Given a password and a cypher text, decrypts the text and returns\r\n * the resulting value.\r\n *\r\n * @param password - The password to decrypt with.\r\n * @param text - The cypher text to decrypt.\r\n * @param encryptionKey - The key to decrypt with.\r\n * @returns The decrypted data.\r\n */\r\nexport async function decrypt(\r\n  password: string,\r\n  text: string,\r\n  encryptionKey?: EncryptionKey | CryptoKey,\r\n): Promise<unknown> {\r\n  const payload = JSON.parse(text);\r\n  const { salt, keyMetadata } = payload;\r\n  const cryptoKey = unwrapKey(\r\n    encryptionKey ||\r\n      (await keyFromPassword(password, salt, false, keyMetadata)),\r\n  );\r\n\r\n  const result = await decryptWithKey(cryptoKey, payload);\r\n  return result;\r\n}\r\n\r\n/**\r\n * Given a password and a cypher text, decrypts the text and returns\r\n * the resulting value, keyString, and salt.\r\n *\r\n * @param password - The password to decrypt with.\r\n * @param text - The encrypted vault to decrypt.\r\n * @returns The decrypted vault along with the salt and exported key.\r\n */\r\nexport async function decryptWithDetail(\r\n  password: string,\r\n  text: string,\r\n): Promise<DetailedDecryptResult> {\r\n  const payload = JSON.parse(text);\r\n  const { salt, keyMetadata } = payload;\r\n  const key = await keyFromPassword(password, salt, true, keyMetadata);\r\n  const exportedKeyString = await exportKey(key);\r\n  const vault = await decrypt(password, text, key);\r\n\r\n  return {\r\n    exportedKeyString,\r\n    vault,\r\n    salt,\r\n  };\r\n}\r\n\r\n/**\r\n * Given a CryptoKey and an EncryptionResult object containing the initialization\r\n * vector (iv) and data to decrypt, return the resulting decrypted value.\r\n *\r\n * @param encryptionKey - The CryptoKey to decrypt with.\r\n * @param payload - The payload to decrypt, returned from an encryption method.\r\n * @returns The decrypted data.\r\n */\r\nexport async function decryptWithKey<R>(\r\n  encryptionKey: EncryptionKey | CryptoKey,\r\n  payload: EncryptionResult,\r\n): Promise<R> {\r\n  const encryptedData = Buffer.from(payload.data, 'base64');\r\n  const vector = Buffer.from(payload.iv, 'base64');\r\n  const key = unwrapKey(encryptionKey);\r\n\r\n  let decryptedObj;\r\n  try {\r\n    const result = await crypto.subtle.decrypt(\r\n      { name: DERIVED_KEY_FORMAT, iv: vector },\r\n      key,\r\n      encryptedData,\r\n    );\r\n\r\n    const decryptedData = new Uint8Array(result);\r\n    const decryptedStr = Buffer.from(decryptedData).toString(STRING_ENCODING);\r\n    decryptedObj = JSON.parse(decryptedStr);\r\n  } catch (e) {\r\n    throw new Error('Incorrect password');\r\n  }\r\n\r\n  return decryptedObj;\r\n}\r\n\r\n/**\r\n * Receives an exported CryptoKey string and creates a key.\r\n *\r\n * This function supports both JsonWebKey's and exported EncryptionKey's.\r\n * It will return a CryptoKey for the former, and an EncryptionKey for the latter.\r\n *\r\n * @param keyString - The key string to import.\r\n * @returns An EncryptionKey or a CryptoKey.\r\n */\r\nexport async function importKey(\r\n  keyString: string,\r\n): Promise<EncryptionKey | CryptoKey> {\r\n  const exportedEncryptionKey = JSON.parse(keyString);\r\n\r\n  if (isExportedEncryptionKey(exportedEncryptionKey)) {\r\n    return {\r\n      key: await globalThis.crypto.subtle.importKey(\r\n        EXPORT_FORMAT,\r\n        exportedEncryptionKey.key,\r\n        DERIVED_KEY_FORMAT,\r\n        true,\r\n        ['encrypt', 'decrypt'],\r\n      ),\r\n      derivationOptions: exportedEncryptionKey.derivationOptions,\r\n    };\r\n  }\r\n\r\n  return await globalThis.crypto.subtle.importKey(\r\n    EXPORT_FORMAT,\r\n    exportedEncryptionKey,\r\n    DERIVED_KEY_FORMAT,\r\n    true,\r\n    ['encrypt', 'decrypt'],\r\n  );\r\n}\r\n\r\n/**\r\n * Exports a key string from a CryptoKey or from an\r\n * EncryptionKey instance.\r\n *\r\n * @param encryptionKey - The CryptoKey or EncryptionKey to export.\r\n * @returns A key string.\r\n */\r\nexport async function exportKey(\r\n  encryptionKey: CryptoKey | EncryptionKey,\r\n): Promise<string> {\r\n  if (isEncryptionKey(encryptionKey)) {\r\n    return JSON.stringify({\r\n      key: await globalThis.crypto.subtle.exportKey(\r\n        EXPORT_FORMAT,\r\n        encryptionKey.key,\r\n      ),\r\n      derivationOptions: encryptionKey.derivationOptions,\r\n    });\r\n  }\r\n\r\n  return JSON.stringify(\r\n    await globalThis.crypto.subtle.exportKey(EXPORT_FORMAT, encryptionKey),\r\n  );\r\n}\r\n\r\n/**\r\n * Generate a CryptoKey from a password and random salt.\r\n *\r\n * @param password - The password to use to generate key.\r\n * @param salt - The salt string to use in key derivation.\r\n * @param exportable - Whether or not the key should be exportable.\r\n * @returns A CryptoKey for encryption and decryption.\r\n */\r\nexport async function keyFromPassword(\r\n  password: string,\r\n  salt: string,\r\n  exportable?: boolean,\r\n): Promise<CryptoKey>;\r\n/**\r\n * Generate a CryptoKey from a password and random salt, specifying\r\n * key derivation options.\r\n *\r\n * @param password - The password to use to generate key.\r\n * @param salt - The salt string to use in key derivation.\r\n * @param exportable - Whether or not the key should be exportable.\r\n * @param opts - The options to use for key derivation.\r\n * @returns An EncryptionKey for encryption and decryption.\r\n */\r\nexport async function keyFromPassword(\r\n  password: string,\r\n  salt: string,\r\n  exportable?: boolean,\r\n  opts?: KeyDerivationOptions,\r\n): Promise<EncryptionKey>;\r\n// The overloads are already documented.\r\n// eslint-disable-next-line jsdoc/require-jsdoc\r\nexport async function keyFromPassword(\r\n  password: string,\r\n  salt: string,\r\n  exportable = false,\r\n  opts: KeyDerivationOptions = OLD_DERIVATION_PARAMS,\r\n): Promise<CryptoKey | EncryptionKey> {\r\n  const passBuffer = Buffer.from(password, STRING_ENCODING);\r\n  const saltBuffer = Buffer.from(salt, 'base64');\r\n\r\n  const key = await globalThis.crypto.subtle.importKey(\r\n    'raw',\r\n    passBuffer,\r\n    { name: 'PBKDF2' },\r\n    false,\r\n    ['deriveBits', 'deriveKey'],\r\n  );\r\n\r\n  const derivedKey = await globalThis.crypto.subtle.deriveKey(\r\n    {\r\n      name: 'PBKDF2',\r\n      salt: saltBuffer,\r\n      iterations: opts.params.iterations,\r\n      hash: 'SHA-256',\r\n    },\r\n    key,\r\n    { name: DERIVED_KEY_FORMAT, length: 256 },\r\n    exportable,\r\n    ['encrypt', 'decrypt'],\r\n  );\r\n\r\n  return opts\r\n    ? {\r\n        key: derivedKey,\r\n        derivationOptions: opts,\r\n      }\r\n    : derivedKey;\r\n}\r\n\r\n/**\r\n * Converts a hex string into a buffer.\r\n *\r\n * @param str - Hex encoded string.\r\n * @returns The string ecoded as a byte array.\r\n */\r\nexport function serializeBufferFromStorage(str: string): Uint8Array {\r\n  const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;\r\n  const buf = new Uint8Array(stripStr.length / 2);\r\n  for (let i = 0; i < stripStr.length; i += 2) {\r\n    const seg = stripStr.substr(i, 2);\r\n    buf[i / 2] = parseInt(seg, 16);\r\n  }\r\n  return buf;\r\n}\r\n\r\n/**\r\n * Converts a buffer into a hex string ready for storage.\r\n *\r\n * @param buffer - Buffer to serialize.\r\n * @returns A hex encoded string.\r\n */\r\nexport function serializeBufferForStorage(buffer: Uint8Array): string {\r\n  let result = '0x';\r\n  buffer.forEach((value) => {\r\n    result += unprefixedHex(value);\r\n  });\r\n  return result;\r\n}\r\n\r\n/**\r\n * Converts a number into hex value, and ensures proper leading 0\r\n * for single characters strings.\r\n *\r\n * @param num - The number to convert to string.\r\n * @returns An unprefixed hex string.\r\n */\r\nfunction unprefixedHex(num: number): string {\r\n  let hex = num.toString(16);\r\n  while (hex.length < 2) {\r\n    hex = `0${hex}`;\r\n  }\r\n  return hex;\r\n}\r\n\r\n/**\r\n * Generates a random string for use as a salt in CryptoKey generation.\r\n *\r\n * @param byteCount - The number of bytes to generate.\r\n * @returns A randomly generated string.\r\n */\r\nexport function generateSalt(byteCount = 32): string {\r\n  const view = new Uint8Array(byteCount);\r\n  globalThis.crypto.getRandomValues(view);\r\n  // Uint8Array is a fixed length array and thus does not have methods like pop, etc\r\n  // so TypeScript complains about casting it to an array. Array.from() works here for\r\n  // getting the proper type, but it results in a functional difference. In order to\r\n  // cast, you have to first cast view to unknown then cast the unknown value to number[]\r\n  // TypeScript ftw: double opt in to write potentially type-mismatched code.\r\n  const b64encoded = btoa(\r\n    String.fromCharCode.apply(null, view as unknown as number[]),\r\n  );\r\n  return b64encoded;\r\n}\r\n\r\n/**\r\n * Updates the provided vault, re-encrypting\r\n * data with a safer algorithm if one is available.\r\n *\r\n * If the provided vault is already using the latest available encryption method,\r\n * it is returned as is.\r\n *\r\n * @param vault - The vault to update.\r\n * @param password - The password to use for encryption.\r\n * @param targetDerivationParams - The options to use for key derivation.\r\n * @returns A promise resolving to the updated vault.\r\n */\r\nexport async function updateVault(\r\n  vault: string,\r\n  password: string,\r\n  targetDerivationParams = DEFAULT_DERIVATION_PARAMS,\r\n): Promise<string> {\r\n  if (isVaultUpdated(vault, targetDerivationParams)) {\r\n    return vault;\r\n  }\r\n\r\n  return encrypt(\r\n    password,\r\n    await decrypt(password, vault),\r\n    undefined,\r\n    undefined,\r\n    targetDerivationParams,\r\n  );\r\n}\r\n\r\n/**\r\n * Updates the provided vault and exported key, re-encrypting\r\n * data with a safer algorithm if one is available.\r\n *\r\n * If the provided vault is already using the latest available encryption method,\r\n * it is returned as is.\r\n *\r\n * @param encryptionResult - The encrypted data to update.\r\n * @param password - The password to use for encryption.\r\n * @param targetDerivationParams - The options to use for key derivation.\r\n * @returns A promise resolving to the updated encrypted data and exported key.\r\n */\r\nexport async function updateVaultWithDetail(\r\n  encryptionResult: DetailedEncryptionResult,\r\n  password: string,\r\n  targetDerivationParams = DEFAULT_DERIVATION_PARAMS,\r\n): Promise<DetailedEncryptionResult> {\r\n  if (isVaultUpdated(encryptionResult.vault, targetDerivationParams)) {\r\n    return encryptionResult;\r\n  }\r\n\r\n  return encryptWithDetail(\r\n    password,\r\n    await decrypt(password, encryptionResult.vault),\r\n    undefined,\r\n    targetDerivationParams,\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if the provided key is an `EncryptionKey`.\r\n *\r\n * @param encryptionKey - The object to check.\r\n * @returns Whether or not the key is an `EncryptionKey`.\r\n */\r\nfunction isEncryptionKey(\r\n  encryptionKey: unknown,\r\n): encryptionKey is EncryptionKey {\r\n  return (\r\n    utils.isPlainObject(encryptionKey) &&\r\n    utils.hasProperty(encryptionKey, 'key') &&\r\n    utils.hasProperty(encryptionKey, 'derivationOptions') &&\r\n    encryptionKey.key instanceof CryptoKey &&\r\n    isKeyDerivationOptions(encryptionKey.derivationOptions)\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if the provided object is a `KeyDerivationOptions`.\r\n *\r\n * @param derivationOptions - The object to check.\r\n * @returns Whether or not the object is a `KeyDerivationOptions`.\r\n */\r\nfunction isKeyDerivationOptions(\r\n  derivationOptions: unknown,\r\n): derivationOptions is KeyDerivationOptions {\r\n  return (\r\n      utils.isPlainObject(derivationOptions) &&\r\n      utils.hasProperty(derivationOptions, 'algorithm') &&\r\n      utils.hasProperty(derivationOptions, 'params')\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if the provided key is an `ExportedEncryptionKey`.\r\n *\r\n * @param exportedKey - The object to check.\r\n * @returns Whether or not the object is an `ExportedEncryptionKey`.\r\n */\r\nfunction isExportedEncryptionKey(\r\n  exportedKey: unknown,\r\n): exportedKey is ExportedEncryptionKey {\r\n    console.log(utils);\r\n  return (\r\n      utils.isPlainObject(exportedKey) &&\r\n      utils.hasProperty(exportedKey, 'key') &&\r\n      utils.hasProperty(exportedKey, 'derivationOptions') &&\r\n    isKeyDerivationOptions(exportedKey.derivationOptions)\r\n  );\r\n}\r\n\r\n/**\r\n * Returns the `CryptoKey` from the provided encryption key.\r\n * If the provided key is a `CryptoKey`, it is returned as is.\r\n *\r\n * @param encryptionKey - The key to unwrap.\r\n * @returns The `CryptoKey` from the provided encryption key.\r\n */\r\nfunction unwrapKey(encryptionKey: EncryptionKey | CryptoKey): CryptoKey {\r\n  return isEncryptionKey(encryptionKey) ? encryptionKey.key : encryptionKey;\r\n}\r\n\r\n/**\r\n * Checks if the provided vault is an updated encryption format.\r\n *\r\n * @param vault - The vault to check.\r\n * @param targetDerivationParams - The options to use for key derivation.\r\n * @returns Whether or not the vault is an updated encryption format.\r\n */\r\nexport function isVaultUpdated(\r\n  vault: string,\r\n  targetDerivationParams = DEFAULT_DERIVATION_PARAMS,\r\n): boolean {\r\n  const { keyMetadata } = JSON.parse(vault);\r\n  return (\r\n    isKeyDerivationOptions(keyMetadata) &&\r\n    keyMetadata.algorithm === targetDerivationParams.algorithm &&\r\n    keyMetadata.params.iterations === targetDerivationParams.params.iterations\r\n  );\r\n}\r\n"]}